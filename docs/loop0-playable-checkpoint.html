<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>BAEK-CHEON-2026 Loop0 Playable Checkpoint (Canvas Scaffold)</title>
    <style>
      :root {
        color-scheme: dark;
        font-family: "Trebuchet MS", system-ui, sans-serif;
      }

      body {
        margin: 0;
        background: #0d0f1a;
        color: #e7eaf6;
        display: grid;
        place-items: center;
        min-height: 100vh;
      }

      .frame {
        width: min(1100px, 92vw);
        background: #141828;
        border: 2px solid #26304f;
        border-radius: 16px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.45);
        padding: 20px;
      }

      header {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-bottom: 12px;
      }

      header h1 {
        margin: 0;
        font-size: 1.4rem;
        color: #f9d26a;
      }

      header p {
        margin: 0;
        color: #9bb2ff;
        font-size: 0.95rem;
      }

      .stage {
        display: grid;
        grid-template-columns: 1fr 280px;
        gap: 16px;
      }

      canvas {
        width: 100%;
        aspect-ratio: 16 / 9;
        background: radial-gradient(circle at 20% 20%, #2b3252, #111424);
        border: 2px solid #2b3a63;
        border-radius: 12px;
      }

      .panel {
        background: #1a2136;
        border: 1px solid #2a355a;
        border-radius: 12px;
        padding: 14px;
        display: grid;
        gap: 12px;
      }

      .panel h2 {
        margin: 0;
        font-size: 1rem;
        color: #8ef0c5;
      }

      .stat {
        display: flex;
        justify-content: space-between;
        font-size: 0.9rem;
        color: #c8d3ff;
      }

      .note {
        font-size: 0.8rem;
        color: #9aa3c7;
        line-height: 1.4;
      }

      .keys {
        display: grid;
        gap: 6px;
        font-size: 0.85rem;
      }

      .keys span {
        background: #10162b;
        border: 1px solid #293456;
        border-radius: 6px;
        padding: 2px 6px;
        font-family: "Courier New", monospace;
        font-size: 0.8rem;
      }
    </style>
  </head>
  <body>
    <div class="frame">
      <header>
        <h1>BAEK-CHEON-2026 Loop0 Playable Checkpoint (Canvas Scaffold)</h1>
        <p>Deterministic fixed-timestep loop with physics integration, collision checks, and stable serialization stub.</p>
      </header>
      <div class="stage">
        <canvas id="gameCanvas" width="960" height="540" aria-label="Loop0 playable checkpoint canvas"></canvas>
        <aside class="panel">
          <h2>Telemetry</h2>
          <div class="stat"><span>Ticks</span><strong id="tickCount">0</strong></div>
          <div class="stat"><span>Lives</span><strong id="lifeCount">3</strong></div>
          <div class="stat"><span>Seed</span><strong id="seedValue">2026</strong></div>
          <div class="stat"><span>Grounded</span><strong id="groundedValue">true</strong></div>
          <div class="stat"><span>Stable Hash</span><strong id="hashValue">-</strong></div>
          <h2>Controls</h2>
          <div class="keys">
            <div><span>←</span>/<span>→</span> Move</div>
            <div><span>Space</span> Jump</div>
            <div><span>R</span> Reset</div>
          </div>
          <p class="note">
            Fixed dt (1/60), deterministic ordering, and a stable stringify stub for later fossilization/receipts.
          </p>
        </aside>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const tickCount = document.getElementById("tickCount");
      const lifeCount = document.getElementById("lifeCount");
      const seedValue = document.getElementById("seedValue");
      const groundedValue = document.getElementById("groundedValue");
      const hashValue = document.getElementById("hashValue");

      const FIXED_DT = 1 / 60;
      const MAX_ACCUMULATOR = 0.25;
      const GRAVITY = 1800;
      const JUMP_VELOCITY = -650;
      const MOVE_SPEED = 260;

      const input = {
        left: false,
        right: false,
        jump: false,
        reset: false,
      };

      const world = {
        seed: 2026,
        tick: 0,
        lives: 3,
        grounded: true,
        player: {
          x: 80,
          y: 340,
          width: 36,
          height: 46,
          vx: 0,
          vy: 0,
        },
        platforms: [
          { id: "ground", x: 0, y: 420, width: 960, height: 120 },
          { id: "step-a", x: 160, y: 350, width: 140, height: 20 },
          { id: "step-b", x: 360, y: 300, width: 160, height: 20 },
          { id: "step-c", x: 600, y: 260, width: 140, height: 20 },
          { id: "step-d", x: 760, y: 220, width: 120, height: 20 },
        ],
      };

      const sortedPlatforms = [...world.platforms].sort((a, b) => a.id.localeCompare(b.id));

      function handleInput(event, isDown) {
        switch (event.code) {
          case "ArrowLeft":
            input.left = isDown;
            break;
          case "ArrowRight":
            input.right = isDown;
            break;
          case "Space":
            input.jump = isDown;
            break;
          case "KeyR":
            input.reset = isDown;
            break;
          default:
            break;
        }
      }

      function updateGame(dt) {
        updatePhysics(dt);
        checkCollisions();
        applyFailSafe();
        world.tick += 1;
      }

      function updatePhysics(dt) {
        const player = world.player;
        const moveAxis = (input.right ? 1 : 0) - (input.left ? 1 : 0);
        player.vx = moveAxis * MOVE_SPEED;

        if (input.jump && world.grounded) {
          player.vy = JUMP_VELOCITY;
          world.grounded = false;
        }

        player.vy += GRAVITY * dt;
        player.x += player.vx * dt;
        player.y += player.vy * dt;

        player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
      }

      function checkCollisions() {
        const player = world.player;
        world.grounded = false;

        for (const platform of sortedPlatforms) {
          if (
            player.x < platform.x + platform.width &&
            player.x + player.width > platform.x &&
            player.y < platform.y + platform.height &&
            player.y + player.height > platform.y
          ) {
            const overlapBottom = platform.y + platform.height - player.y;
            const overlapTop = player.y + player.height - platform.y;
            if (overlapTop < overlapBottom && player.vy >= 0) {
              player.y = platform.y - player.height;
              player.vy = 0;
              world.grounded = true;
            }
          }
        }
      }

      function applyFailSafe() {
        const player = world.player;
        if (player.y > canvas.height + 120) {
          world.lives = Math.max(0, world.lives - 1);
          resetPlayer();
        }
        if (input.reset) {
          world.lives = 3;
          resetPlayer();
        }
      }

      function resetPlayer() {
        world.player.x = 80;
        world.player.y = 340;
        world.player.vx = 0;
        world.player.vy = 0;
        world.grounded = true;
      }

      function stableStringify(value) {
        if (value === null || typeof value !== "object") {
          return JSON.stringify(value);
        }
        if (Array.isArray(value)) {
          return `[${value.map((item) => stableStringify(item)).join(",")}]`;
        }
        const keys = Object.keys(value).sort();
        return `{${keys.map((key) => `${JSON.stringify(key)}:${stableStringify(value[key])}`).join(",")}}`;
      }

      function computeStableHash() {
        const snapshot = {
          tick: world.tick,
          lives: world.lives,
          grounded: world.grounded,
          player: world.player,
        };
        const serialized = stableStringify(snapshot);
        let hash = 0;
        for (let i = 0; i < serialized.length; i += 1) {
          hash = (hash * 31 + serialized.charCodeAt(i)) >>> 0;
        }
        return hash.toString(16).padStart(8, "0");
      }

      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "#0f1324";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "#263a63";
        for (const platform of sortedPlatforms) {
          ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
        }

        ctx.fillStyle = "#f2b632";
        const player = world.player;
        ctx.fillRect(player.x, player.y, player.width, player.height);

        ctx.fillStyle = "#94d1ff";
        ctx.font = "16px 'Courier New', monospace";
        ctx.fillText("Loop0 Playable Checkpoint", 20, 32);
      }

      function updateTelemetry() {
        tickCount.textContent = world.tick.toString();
        lifeCount.textContent = world.lives.toString();
        seedValue.textContent = world.seed.toString();
        groundedValue.textContent = world.grounded ? "true" : "false";
        hashValue.textContent = computeStableHash();
      }

      let accumulator = 0;
      let lastTime = performance.now();

      function frame(time) {
        const deltaSeconds = Math.min((time - lastTime) / 1000, MAX_ACCUMULATOR);
        accumulator = Math.min(accumulator + deltaSeconds, MAX_ACCUMULATOR);

        while (accumulator >= FIXED_DT) {
          updateGame(FIXED_DT);
          accumulator -= FIXED_DT;
        }

        render();
        updateTelemetry();
        lastTime = time;
        requestAnimationFrame(frame);
      }

      window.addEventListener("keydown", (event) => handleInput(event, true));
      window.addEventListener("keyup", (event) => handleInput(event, false));

      requestAnimationFrame(frame);
    </script>
  </body>
</html>
